// This was generated by a dumb python script! Don't edit!! //

impl<'a> CPU<'a> {
    pub fn opmatch(&mut self, op: u8) -> bool {
        match op {
            0x69 => { // ADC IMM
                let result: bool = self.adc(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x65 => { // ADC ZP
                let result: bool = self.adc(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x75 => { // ADC ZPX
                let result: bool = self.adc(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x6d => { // ADC ABS
                let result: bool = self.adc(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x7d => { // ADC ABSX
                let result: bool = self.adc(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x79 => { // ADC ABSY
                let result: bool = self.adc(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x61 => { // ADC INDX
                let result: bool = self.adc(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x71 => { // ADC INDY
                let result: bool = self.adc(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x0b => { // ANC IMM
                let result: bool = self.anc(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x2b => { // ANC IMM
                let result: bool = self.anc(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x29 => { // AND IMM
                let result: bool = self.and(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x25 => { // AND ZP
                let result: bool = self.and(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x35 => { // AND ZPX
                let result: bool = self.and(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x2d => { // AND ABS
                let result: bool = self.and(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x3d => { // AND ABSX
                let result: bool = self.and(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x39 => { // AND ABSY
                let result: bool = self.and(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x21 => { // AND INDX
                let result: bool = self.and(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x31 => { // AND INDY
                let result: bool = self.and(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x0a => { // ASL ACC
                let result: bool = self.asl_accumulator(&AddressingMode::Accumulator);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x06 => { // ASL ZP
                let result: bool = self.asl(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x16 => { // ASL ZPX
                let result: bool = self.asl(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x0e => { // ASL ABS
                let result: bool = self.asl(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x1e => { // ASL ABSX
                let result: bool = self.asl(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x90 => { // BCC REL
                let result: bool = self.bcc(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xB0 => { // BCS REL
                let result: bool = self.bcs(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xF0 => { // BEQ REL
                let result: bool = self.beq(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x30 => { // BMI REL
                let result: bool = self.bmi(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xD0 => { // BNE REL
                let result: bool = self.bne(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x10 => { // BPL REL
                let result: bool = self.bpl(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x50 => { // BVC REL
                let result: bool = self.bvc(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x70 => { // BVS REL
                let result: bool = self.bvs(&AddressingMode::Relative);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x24 => { // BIT ZP
                let result: bool = self.bit(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x2c => { // BIT ABS
                let result: bool = self.bit(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x00 => { // BRK IMP
                let result: bool = self.brk(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x18 => { // CLC IMP
                let result: bool = self.clc(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xd8 => { // CLD IMP
                let result: bool = self.cld(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x58 => { // CLI IMP
                let result: bool = self.cli(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xb8 => { // CLV IMP
                let result: bool = self.clv(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xea => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x48 => { // PHA IMP
                let result: bool = self.pha(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x68 => { // PLA IMP
                let result: bool = self.pla(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x08 => { // PHP IMP
                let result: bool = self.php(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x28 => { // PLP IMP
                let result: bool = self.plp(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x40 => { // RTI IMP
                let result: bool = self.rti(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x60 => { // RTS IMP
                let result: bool = self.rts(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x38 => { // SEC IMP
                let result: bool = self.sec(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xf8 => { // SED IMP
                let result: bool = self.sed(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x78 => { // SEI IMP
                let result: bool = self.sei(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xaa => { // TAX IMP
                let result: bool = self.tax(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x8a => { // TXA IMP
                let result: bool = self.txa(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xa8 => { // TAY IMP
                let result: bool = self.tay(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x98 => { // TYA IMP
                let result: bool = self.tya(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xba => { // TSX IMP
                let result: bool = self.tsx(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x9a => { // TXS IMP
                let result: bool = self.txs(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xc9 => { // CMP IMM
                let result: bool = self.cmp(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xc5 => { // CMP ZP
                let result: bool = self.cmp(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xd5 => { // CMP ZPX
                let result: bool = self.cmp(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xcd => { // CMP ABS
                let result: bool = self.cmp(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xdd => { // CMP ABSX
                let result: bool = self.cmp(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xd9 => { // CMP ABSY
                let result: bool = self.cmp(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xc1 => { // CMP INDX
                let result: bool = self.cmp(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xd1 => { // CMP INDY
                let result: bool = self.cmp(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xe0 => { // CPX IMM
                let result: bool = self.cpx(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xe4 => { // CPX ZP
                let result: bool = self.cpx(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xec => { // CPX ABS
                let result: bool = self.cpx(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xc0 => { // CPY IMM
                let result: bool = self.cpy(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xc4 => { // CPY ZP
                let result: bool = self.cpy(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xcc => { // CPY ABS
                let result: bool = self.cpy(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xc6 => { // DEC ZP
                let result: bool = self.dec(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xd6 => { // DEC ZPX
                let result: bool = self.dec(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xce => { // DEC ABS
                let result: bool = self.dec(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xde => { // DEC ABSX
                let result: bool = self.dec(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xca => { // DEX IMP
                let result: bool = self.dex(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x88 => { // DEY IMP
                let result: bool = self.dey(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xe8 => { // INX IMP
                let result: bool = self.inx(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xc8 => { // INY IMP
                let result: bool = self.iny(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x49 => { // EOR IMM
                let result: bool = self.eor(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x45 => { // EOR ZP
                let result: bool = self.eor(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x55 => { // EOR ZPX
                let result: bool = self.eor(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x4d => { // EOR ABS
                let result: bool = self.eor(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x5d => { // EOR ABSX
                let result: bool = self.eor(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x59 => { // EOR ABSY
                let result: bool = self.eor(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x41 => { // EOR INDX
                let result: bool = self.eor(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x51 => { // EOR INDY
                let result: bool = self.eor(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xe6 => { // INC ZP
                let result: bool = self.inc(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xf6 => { // INC ZPX
                let result: bool = self.inc(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xee => { // INC ABS
                let result: bool = self.inc(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xfe => { // INC ABSX
                let result: bool = self.inc(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x4c => { // JMP ABS
                let result: bool = self.jmp(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x6c => { // JMP IND
                let result: bool = self.jmp(&AddressingMode::Indirect);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x20 => { // JSR ABS
                let result: bool = self.jsr(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xa9 => { // LDA IMM
                let result: bool = self.lda(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xa5 => { // LDA ZP
                let result: bool = self.lda(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xb5 => { // LDA ZPX
                let result: bool = self.lda(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xad => { // LDA ABS
                let result: bool = self.lda(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xbd => { // LDA ABSX
                let result: bool = self.lda(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xb9 => { // LDA ABSY
                let result: bool = self.lda(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xa1 => { // LDA INDX
                let result: bool = self.lda(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xb1 => { // LDA INDY
                let result: bool = self.lda(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xa2 => { // LDX IMM
                let result: bool = self.ldx(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xa6 => { // LDX ZP
                let result: bool = self.ldx(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xb6 => { // LDX ZPY
                let result: bool = self.ldx(&AddressingMode::ZeroPageY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xae => { // LDX ABS
                let result: bool = self.ldx(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xbe => { // LDX ABSY
                let result: bool = self.ldx(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xa0 => { // LDY IMM
                let result: bool = self.ldy(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xa4 => { // LDY ZP
                let result: bool = self.ldy(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xb4 => { // LDY ZPX
                let result: bool = self.ldy(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xac => { // LDY ABS
                let result: bool = self.ldy(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xbc => { // LDY ABSX
                let result: bool = self.ldy(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x4a => { // LSR ACC
                let result: bool = self.lsr_accumulator(&AddressingMode::Accumulator);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x46 => { // LSR ZP
                let result: bool = self.lsr(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x56 => { // LSR ZPX
                let result: bool = self.lsr(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x4e => { // LSR ABS
                let result: bool = self.lsr(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x5e => { // LSR ABSX
                let result: bool = self.lsr(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x09 => { // ORA IMM
                let result: bool = self.ora(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x05 => { // ORA ZP
                let result: bool = self.ora(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x15 => { // ORA ZPX
                let result: bool = self.ora(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x0d => { // ORA ABS
                let result: bool = self.ora(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x1d => { // ORA ABSX
                let result: bool = self.ora(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x19 => { // ORA ABSY
                let result: bool = self.ora(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x01 => { // ORA INDX
                let result: bool = self.ora(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x11 => { // ORA INDY
                let result: bool = self.ora(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x2a => { // ROL ACC
                let result: bool = self.rol_accumulator(&AddressingMode::Accumulator);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x26 => { // ROL ZP
                let result: bool = self.rol(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x36 => { // ROL ZPX
                let result: bool = self.rol(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x2e => { // ROL ABS
                let result: bool = self.rol(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x3e => { // ROL ABSX
                let result: bool = self.rol(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x6a => { // ROR ACC
                let result: bool = self.ror_accumulator(&AddressingMode::Accumulator);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x66 => { // ROR ZP
                let result: bool = self.ror(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x76 => { // ROR ZPX
                let result: bool = self.ror(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x6e => { // ROR ABS
                let result: bool = self.ror(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x7e => { // ROR ABSX
                let result: bool = self.ror(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xe9 => { // SBC IMM
                let result: bool = self.sbc(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xe5 => { // SBC ZP
                let result: bool = self.sbc(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xf5 => { // SBC ZPX
                let result: bool = self.sbc(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xed => { // SBC ABS
                let result: bool = self.sbc(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xfd => { // SBC ABSX
                let result: bool = self.sbc(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xf9 => { // SBC ABSY
                let result: bool = self.sbc(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xe1 => { // SBC INDX
                let result: bool = self.sbc(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xf1 => { // SBC INDY
                let result: bool = self.sbc(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x85 => { // STA ZP
                let result: bool = self.sta(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x95 => { // STA ZPX
                let result: bool = self.sta(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x8d => { // STA ABS
                let result: bool = self.sta(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x9d => { // STA ABSX
                let result: bool = self.sta(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x99 => { // STA ABSY
                let result: bool = self.sta(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x81 => { // STA INDX
                let result: bool = self.sta(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x91 => { // STA INDY
                let result: bool = self.sta(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x86 => { // STX ZP
                let result: bool = self.stx(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x96 => { // STX ZPY
                let result: bool = self.stx(&AddressingMode::ZeroPageY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x8e => { // STX ABS
                let result: bool = self.stx(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x84 => { // STY ZP
                let result: bool = self.sty(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x94 => { // STY ZPX
                let result: bool = self.sty(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x8c => { // STY ABS
                let result: bool = self.sty(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x04 => { // NOP ZP
                let result: bool = self.nop(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x44 => { // NOP ZP
                let result: bool = self.nop(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x64 => { // NOP ZP
                let result: bool = self.nop(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x14 => { // NOP ZPX
                let result: bool = self.nop(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x34 => { // NOP ZPX
                let result: bool = self.nop(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x54 => { // NOP ZPX
                let result: bool = self.nop(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x74 => { // NOP ZPX
                let result: bool = self.nop(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xd4 => { // NOP ZPX
                let result: bool = self.nop(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xf4 => { // NOP ZPX
                let result: bool = self.nop(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x0c => { // NOP ABS
                let result: bool = self.nop(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x1c => { // NOP ABSX
                let result: bool = self.nop(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x3c => { // NOP ABSX
                let result: bool = self.nop(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x5c => { // NOP ABSX
                let result: bool = self.nop(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x7c => { // NOP ABSX
                let result: bool = self.nop(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xdc => { // NOP ABSX
                let result: bool = self.nop(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xfc => { // NOP ABSX
                let result: bool = self.nop(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x1a => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x3a => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x5a => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x7a => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xda => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xfa => { // NOP IMP
                let result: bool = self.nop(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x02 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x12 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x22 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x32 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x42 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x52 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x62 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x72 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x92 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xb2 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xd2 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0xf2 => { // HLT IMP
                let result: bool = self.hlt(&AddressingMode::Implied);
                self.pc = self.pc.wrapping_add(0);
                result
            }

            0x80 => { // NOP IMM
                let result: bool = self.nop(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x82 => { // NOP IMM
                let result: bool = self.nop(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x89 => { // NOP IMM
                let result: bool = self.nop(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xc2 => { // NOP IMM
                let result: bool = self.nop(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xe2 => { // NOP IMM
                let result: bool = self.nop(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x07 => { // SLO ZP
                let result: bool = self.slo(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x17 => { // SLO ZPX
                let result: bool = self.slo(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x0f => { // SLO ABS
                let result: bool = self.slo(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x1f => { // SLO ABSX
                let result: bool = self.slo(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x1b => { // SLO ABSY
                let result: bool = self.slo(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x03 => { // SLO INDX
                let result: bool = self.slo(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x13 => { // SLO INDY
                let result: bool = self.slo(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xe7 => { // ISB ZP
                let result: bool = self.isb(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xf7 => { // ISB ZPX
                let result: bool = self.isb(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xef => { // ISB ABS
                let result: bool = self.isb(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xff => { // ISB ABSX
                let result: bool = self.isb(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xfb => { // ISB ABSY
                let result: bool = self.isb(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xe3 => { // ISB INDX
                let result: bool = self.isb(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xf3 => { // ISB INDY
                let result: bool = self.isb(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x47 => { // SRE ZP
                let result: bool = self.sre(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x57 => { // SRE ZPX
                let result: bool = self.sre(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x4f => { // SRE ABS
                let result: bool = self.sre(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x5f => { // SRE ABSX
                let result: bool = self.sre(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x5b => { // SRE ABSY
                let result: bool = self.sre(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x43 => { // SRE INDX
                let result: bool = self.sre(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x53 => { // SRE INDY
                let result: bool = self.sre(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x67 => { // RRA ZP
                let result: bool = self.rra(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x77 => { // RRA ZPX
                let result: bool = self.rra(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x6f => { // RRA ABS
                let result: bool = self.rra(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x7f => { // RRA ABSX
                let result: bool = self.rra(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x7b => { // RRA ABSY
                let result: bool = self.rra(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x63 => { // RRA INDX
                let result: bool = self.rra(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x73 => { // RRA INDY
                let result: bool = self.rra(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xa7 => { // LAX ZP
                let result: bool = self.lax(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xb7 => { // LAX ZPY
                let result: bool = self.lax(&AddressingMode::ZeroPageY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xaf => { // LAX ABS
                let result: bool = self.lax(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xbf => { // LAX ABSY
                let result: bool = self.lax(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xa3 => { // LAX INDX
                let result: bool = self.lax(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xb3 => { // LAX INDY
                let result: bool = self.lax(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x87 => { // SAX ZP
                let result: bool = self.sax(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x97 => { // SAX ZPY
                let result: bool = self.sax(&AddressingMode::ZeroPageY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x8f => { // SAX ABS
                let result: bool = self.sax(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x83 => { // SAX INDX
                let result: bool = self.sax(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xeb => { // SBC IMM
                let result: bool = self.sbc(&AddressingMode::Immediate);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xc7 => { // DCP ZP
                let result: bool = self.dcp(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xd7 => { // DCP ZPX
                let result: bool = self.dcp(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xcf => { // DCP ABS
                let result: bool = self.dcp(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xdf => { // DCP ABSX
                let result: bool = self.dcp(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xdb => { // DCP ABSY
                let result: bool = self.dcp(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0xd3 => { // DCP INDY
                let result: bool = self.dcp(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0xc3 => { // DCP INDX
                let result: bool = self.dcp(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x27 => { // RLA ZP
                let result: bool = self.rla(&AddressingMode::ZeroPage);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x37 => { // RLA ZPX
                let result: bool = self.rla(&AddressingMode::ZeroPageX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x2f => { // RLA ABS
                let result: bool = self.rla(&AddressingMode::Absolute);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x3f => { // RLA ABSX
                let result: bool = self.rla(&AddressingMode::AbsoluteX);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x3b => { // RLA ABSY
                let result: bool = self.rla(&AddressingMode::AbsoluteY);
                self.pc = self.pc.wrapping_add(2);
                result
            }

            0x33 => { // RLA INDY
                let result: bool = self.rla(&AddressingMode::IndirectY);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            0x23 => { // RLA INDX
                let result: bool = self.rla(&AddressingMode::IndirectX);
                self.pc = self.pc.wrapping_add(1);
                result
            }

            _ => {
                println!("[CPU] unimplemented opcode! 0x{:02x}", op);
                false
            }
        }
    }
}
    